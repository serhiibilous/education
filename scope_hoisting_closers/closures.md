## Замыкание (Closures)

# Определение

**Замыкание** — это когда функция умеет запоминать 
и имеет доступ к лексической области видимости даже тогда, 
когда эта функция выполняется вне своей лексической области видимости.

```js
function foo() {
	var a = 2;

	function bar() {
		console.log( a );
	}

	return bar;
}

var baz = foo();

baz(); // 2 -- Вот это и есть замыкание!
```

Благодаря тому, где она была объявлена, 
у `bar()` есть замыкание лексической области видимости на внутреннею область видимости `foo(),` 
которая удерживает область видимости для `bar()`, чтобы ссылаться на нее позднее.

**`bar()` все еще содержит ссылку на эту область видимости и эта ссылка называется замыканием.**

## Циклы + замыкание

Самый распространенный канонический пример, 
используемый для иллюстрации замыкания, приводят с использованием скромного цикла `for`.

```js
for (var i=1; i<=5; i++) {
	setTimeout( function timer(){
		console.log( i );
	}, i*1000 );
}
```

**Результат:** нам выведется число `6` пять раз.

Нам не хватает того, что мы пытаемся предполагать, что каждая итерация цикла "захватывает" 
свою собственную копию `i` во время выполнения итерации. 
Но, тем путем, которым работает область видимости, все 5 этих функций, 
хотя они и определяются отдельно в каждой итерации цикла, 
все они замыкаются на одну и ту же **глобальную разделяемую область видимости**, в которой, 
фактически, только одна переменная `i`.

Как это исправить (3 способа):

1. Завернуть таймаут в IIFE функцию, которая создает свою собственную область видимости, 
   и создать внутри нне еще одну переменную значение которой будет `i`.
   
    ```js
    for (var i=1; i<=5; i++) {
        (function(){
            var j = i;
            setTimeout( function timer(){
                console.log( j );
            }, j*1000 );
        })();
    }
    ```

2. Прокинуть значение переменной счетчика как параметр в IIFE функцию.

    ```js
    for (var i=1; i<=5; i++) {
        (function(j){
            setTimeout( function timer(){
                console.log( j );
            }, j*1000 );
        })( j );
    }
    ```
   
3. Использовать блочную область видимости, с помощью объявления переменной через `let`.

    ```js
    for (let i=1; i<=5; i++) {
        setTimeout( function timer(){
            console.log( i );
        }, i*1000 );
    }
    ```
   
## Модули

Паттерны программирования `Модуль`, который эффективно используют мощь замыканий, 
но который внешне не особенно похожи на функции обратного вызова.

```js
function CoolModule() {
	var something = "cool";
	var another = [1, 2, 3];

	function doSomething() {
		console.log( something );
	}

	function doAnother() {
		console.log( another.join( " ! " ) );
	}

	return {
		doSomething: doSomething,
		doAnother: doAnother
	};
}

var foo = CoolModule();

foo.doSomething(); // cool
foo.doAnother(); // 1 ! 2 ! 3
```

### Особенности:

- `CoolModule()` — просто функция, но ее надлежит вызвать для создания объекта модуля. 
  Без выполнения внешней функции не случится ни создание внутренней области видимости, 
  ни создание замыканий.
  
- функция `CoolModule()` возвращает объект, 
  выполненный в синтаксисе объектного литерала `{ key: value, ... }`. 
  У объекта, который мы возвращаем, есть ссылки на наши внутренние функции, 
  но не на наши внутренние переменные. Мы храним их скрытыми и приватными. 
  Правильнее всего будет думать о возвращаемом значении в виде объекта, 
  как по существу о публичном API для нашего модуля.
  
- У функций `doSomething()` и `doAnother()` есть замыкание
  на внутреннюю область видимости "экземпляра" модуля
  (полученного на самом деле вызовом `CoolModule()`).
  Когда мы передаем эти функции вне лексической области видимости
  путем ссылок на свойства объекта, который мы возвращаем,
  то мы в этот момент фактически получаем условия,
  при которых замыкание может появиться и выполниться.

**Модули — это всего лишь функции, поэтому они могут принимать параметры:**

```js
function CoolModule(id) {
	function identify() {
		console.log( id );
	}

	return {
		identify: identify
	};
}

var foo1 = CoolModule( "foo 1" );
var foo2 = CoolModule( "foo 2" );

foo1.identify(); // "foo 1"
foo2.identify(); // "foo 2"
```

## Суммируя и отвечая на вопрос, что такое `Closures` — Замыкание:

**Замыкание** — это когда функция умеет запоминать
и имеет доступ к лексической области видимости даже тогда,
когда эта функция выполняется вне своей лексической области видимости.

Стоит привести пример:

```js
// Функция что имеет в себе замыкание
function foo() {
    // Локальная переменная к которой нету доступа из вне
	var a = 2;

	// Функция что выводит локальную переменную
	function bar() {
		console.log( a );
	}

	// у `bar()` есть замыкание лексической области видимости на внутренную область видимости foo()
	return bar;
}

var baz = foo();

// При этом вызове `bar()` то есть `baz()` 
// все еще содержит ссылку на эту область видимости и эта ссылка называется замыканием.


baz(); // 2
```

Или сказать простыми словами:
Что мы замкнули значение `a` внутри `foo()`.

Так же нужно быть готовым объяснить поведение замыкания в циклах `for` с использованием `setTimeout`.
_Очень популярный вопрос на собеседовании_
